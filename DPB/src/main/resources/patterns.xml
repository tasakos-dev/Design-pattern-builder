<?xml version="1.0" encoding="UTF-8"?>
<GoF xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:noNamespaceSchemaLocation="patterns_schema.xsd">
	<category id="creational">
		<pattern id="Abstract Factory">
			<description>Provide an interface for creating families of related or dependent objects without specifying their concrete classes.</description>
			<interface id="AbstractFactory">
					<method id="createProductA">
						<type>ProductA</type>
					</method>
					<method id="createProductB">
						<type>ProductB</type>
					</method>
			</interface>
			<interface id="ProductA">
				<method id="doStuff">
					<type>void</type>
				</method>
			</interface>
			<interface id="ProductB">
				<method id="doStuff">
					<type>void</type>
				</method>
			</interface>
			<class id="concreteFactory1" implements="AbstractFactory"></class>
			<class id="concreteFactory2" implements="AbstractFactory"></class>
			<class id="concreteProductA1" implements="ProductA"></class>
			<class id="concreteProductA2" implements="ProductA"></class>
			<class id="concreteProductB1" implements="ProductB"></class>
			<class id="concreteProductB2" implements="ProductB"></class>
			<properties>
				<newClass implements= "AbstractFactory" />
				<newClass implements= "ProductA"/>
				<newClass implements= "ProductB"/>
				<newMethod belongs="AbstractFactory"/>
			</properties>
		</pattern>
		<pattern id="Builder">
			<description>Separate the construction of a complex object from its representation so that thesame construction process can create different representations.</description>
			<interface id="Builder">
				<method id="buildPart">
					<type>void</type>
				</method>
			</interface>
			<class id="ConcreteBuilder" implements="Builder"></class>
			<class id="Director">
				<field id="builder">
					<type>Builder</type>
				</field>
				<method id="construct">
					<type>void</type>
					<code>
						/*
							for all objects in structure {
								builder.buildPart();
							}
						*/
						
					</code>
				</method>
			</class>
			<properties>
				<newClass implements="Builder"/>
			</properties>
		</pattern>
		<pattern id="Factory Method">
			<description>Define an interface for creating an object, but let subclasses decide which class to instantiate.
			 Factory Method lets a class defer instantiation to subclasses.</description>
			<interface id="Product">
				<method id="doStuff">
					<type>void</type>
				</method>
			</interface>
			<class id="Creator" isAbstract="true">
					<method id="factoryMethodA" isAbstract="true">
						<type>Product</type>
					</method>
					<method id="anOperation">
						<type>void</type>
					</method>
			</class>
			<class id="ConcreteCreator" extends="Creator"></class>
			<class id="ConcreteProductA" implements="Product"></class>
			<properties>
				<newClass implements="Product"/>
				<newMethod belongs="Creator" />
			</properties>
		</pattern>
		<pattern id="Prototype">
			<description>Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.</description>
			<interface id="Prototype">
				<method id="clone">
					<type>Prototype</type>
					<code>
						return super.clone();
					</code>
				</method>
			</interface>
			<class id="ConcretePrototype1" implements="Prototype">
				<method id="clone">
					<type>Prototype</type>
					<code>
						try {
							return (Prototype) super.clone();
						} catch (CloneNotSupportedException e) {
							e.printStackTrace();
						}
						return null;
					</code>
				</method>
			</class>
			<class id="ConcretePrototype2" implements="Prototype">
				<method id="clone">
					<type>Prototype</type>
					<code>
						try {
							return (Prototype) super.clone();
						} catch (CloneNotSupportedException e) {
							e.printStackTrace();
						}
						return null;
					</code>
				</method>
			</class>
			<class id="Client">
				<field id="prototype">
					<type>
						Prototype
					</type>
				</field>
				<method id="operation">
					<type>void</type>
					<code>
						Prototype p = null;
						p = prototype.clone();
					</code>
				</method>
			</class>
			<properties>
				<newClass implements="Prototype"/>
			</properties>
		</pattern>
		<pattern id="Singleton">
			<description>Ensure a class only has one instance, and provide a global point of access to it.</description>
			<class id="Singleton">
				<field id="instance" isStatic="true">
					<type>Singleton</type>
				</field>
				<method id="Singleton" visibility="private">
					<type></type>
				</method>
				<method id="getInstance" isStatic="true">
					<type>Object</type>
					<code>
						if (instance == null) {
							instance = new Singleton();
						}
						return instance;
					</code>
				</method>
			</class>
		</pattern>
	</category>
	<category id="Structural">
		<pattern id="Object Adapter">
			<description>Convert the interface of a class into another interface clients expect.
			 Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.</description>
			<interface id="Target">
				<method id="request">
					<type>void</type>
				</method>				
			</interface>
			<class id="Adapter" implements="Target">
				<field id="adaptee"><type>Adaptee</type></field>
				<method id="request">
					<type>void</type>
					<code>
						adaptee.specificRequest();
					</code>
				</method>	
			</class>
			<class id="Adaptee">
				<method id="specificRequest">
					<type>void</type>
				</method>	
			</class>
			<class id="client">
				<field id="target">
					<type>Target</type>
				</field>
			</class>
		</pattern>
		<pattern id="Class Adapter">
			<description>Convert the interface of a class into another interface clients expect.
			 Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.</description>
			<interface id="Target">
				<method id="request">
					<type>void</type>
				</method>				
			</interface>
			<class id="Adapter" implements="Target" extends="Adaptee">
				<method id="request">
					<type>void</type>
					<code>
						super.specificRequest();
					</code>
				</method>	
			</class>
			<class id="Adaptee">
				<method id="specificRequest">
					<type>void</type>
				</method>	
			</class>
			<class id="client">
				<field id="target">
					<type>Target</type>
				</field>
			</class>
		</pattern>
		<pattern id="Bridge">
			<description>Decouple an abstraction from its implementation so that the two can vary independently.</description>
			<interface id="Implementor">
				<method id="operationImp">
					<type>void</type>
				</method>
			</interface>
			<class id="Abstraction">
				<field id="imp">
					<type>Implementor</type>
				</field>
				<method id="operation">
					<type>void</type>
					<code>
						imp.operationImp();
					</code>
				</method>
			</class>
			<class id="RefinedAbstraction" extends="Abstraction"></class>
			<class id="ConcreteImplementorA" implements="Implementor"></class>
			<class id="ConcreteImplementorB" implements="Implementor"></class>			
		</pattern>
		<pattern id="Composite">
			<description>Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.</description>
			<interface id="Component">
				<method id="operation">
					<type>void</type>
				</method>
			</interface>
			<class id="Leaf" implements="Component"></class>
			<class id="Composite" implements="Component">
				<field id="children"><type>Component[]</type></field>
				<method id="add">
					<type>void</type>
					<parameter id="c"><type>Component</type></parameter>
				</method>
				<method id="remove">
					<type>void</type>
					<parameter id="c"><type>Component</type></parameter>
				</method>
				<method id="getChildren"><type>Component</type></method>
			</class>
		</pattern>
		<pattern id="Decorator">
			<description>Attach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.</description>
			<interface id="Component">
				<method id="operation"><type>void</type></method>
			</interface>
			<class id="ConcreteComponent" implements="Component"></class>
			<class id="Decorator" implements="Component" isAbstract="true">
				<field id="component"><type>Component</type></field>
				<method id="operation">
					<type>void</type>
					<code>component.operation();</code>
				</method>
			</class>
			<class id="ConcreteDecoratorA" extends="Decorator">
				<method id="addedBehavior"><type>void</type></method>
				<method id="operation">
					<type>void</type>
					<code>
						super.operation();
						addedBehavior();
					</code>
				</method>
			</class>
			<class id="ConcreteDecoratorB" extends="Decorator">
				<field id="addedState"><type>Object</type></field>
			</class>
		</pattern>
		<pattern id="Facade">
			<description>Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.</description>
			<class id="Subsystem1">
				<method id="operation">
					<type>void</type>
				</method>
			</class>
			<class id="Facade">
				<field id="subsystem"><type>Subsystem1</type></field>
				<method id="subsystemOperation">
					<type>void</type>
					<code>
						subsystem.operation();
					</code>
					</method>
			</class>
		</pattern>
		<pattern id="Flyweight">
			<description>Use sharing to support large numbers of fine-grained objects efficiently.</description>
			<class id="Flyweight" isAbstract="true">
				<field id="repeatingState"><type>Object</type></field>
				<method id="operation" isAbstract="true">
					<type>void</type>
					<parameter id="extinsicState"><type>Object</type></parameter>
				</method>
			</class>
			<class id="FlyweightFactory">
				<field id="flyweights"><type>Flyweight[]</type></field>
				<method id="getFlyweight">
					<type>Flyweight</type>
					<parameter id="key"><type>int</type></parameter>
					<code>
						if (flyweights[key] == null) {
							flyweights[key] = new ConcreteFlyweight();
						}
						return flyweights[key];
					</code>
				</method>
			</class>
			<class id="ConcreteFlyweight" extends="Flyweight">
				<field id="intrinsicState"><type>Object</type></field>
			</class>
			<class id="UnsharedConcreteFlyweight" extends="Flyweight">
				<field id="allState"><type>Object</type></field>
			</class>
		</pattern>
		<pattern id="Proxy">
			<description>Provide a surrogate or placeholder for another object to control access to it.</description>
			<interface id="Subject">
				<method id="request">
					<type>void</type>
				</method>
			</interface>
			<class id="Proxy" implements="Subject">
				<field id="realService"><type>RealService</type></field>
				<method id="checkAccess"><type>boolean</type>
					<code>
						return false;
					</code>
				</method>
				<method id="request">
					<type>void</type>
					<code>
						if (checkAccess()){
							realService.request();
						}
					</code>
				</method>
			</class>
			<class id="RealService">
				<method id="request"><type>void</type></method>
			</class>
		</pattern>
		
	</category>
	<category id="Behavioral">
		<pattern id="Chain of Responsibility">
			<description>Avoid coupling the sender of a request to its receiver by 
			giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.</description>
			<class id="Handler">
				<field id="successor"><type>Handler</type></field>
				<method id="setSuccessor">
					<type>void</type>
					<parameter id="successor1"><type>Handler</type></parameter>
					<code>
						this.successor = successor1;
					</code>
				</method>
				<method id="handleRequest">
					<type>void</type>
					<code>
						if (successor != null) {
							successor.handleRequest();
						}
					</code>
				</method>
			</class>
			<class id="ConcreteHandler1" extends="Handler">
			</class>
			<class id="ConcreteHandler2" extends="Handler">
			</class>			
		</pattern>
		<pattern id="Command">
			<description>Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.</description>
			<interface id="Command">
				<method id="execute">
					<type>void</type>
				</method>
			</interface>
			<class id="ConcreteCommand" implements="Command">
				<field id="state"><type>Object</type></field>
				<field id="receiver"><type>Receiver</type></field>
				<method id="execute">
					<type>void</type>
					<code>
						receiver.action();
					</code>
				</method>
			</class>
			<class id="Receiver">
				<method id="action">
					<type>void</type>
				</method>
			</class>
			<class id="Invoker">
				<field id="command"><type>Command</type></field>
				<method id="setCommand">
					<type>void</type>
					<parameter id="command"><type>Command</type></parameter>
					<code>
						this.command = command;
					</code>
				</method>
				<method id="executeCommand">
					<type>void</type>
					<code>
						command.execute();
					</code>
				</method>
			</class>
		</pattern>
		<pattern id="Interpeter">
			<description>Given a language, define a represention for its grammar along with an interpreter that uses the representation to interpret sentences in the language.</description>
			<interface id="AbstractExpression">
				<method id="interpet">
					<type>void</type>
					<parameter id="context"><type>Context</type></parameter>
				</method>
			</interface>
			<class id="TerminalExpression" implements="AbstractExpression"></class>
			<class id="NonTerminalExpression" implements="AbstractExpression">
				<field id="expression"><type>AbstractExpression</type></field>
			</class>
			<class id="Context"></class>
			<class id="Client">
				<field id="context"><type>Context</type></field>
				<field id="expr"><type>AbstractExpression</type></field>
			</class>
		</pattern>
		<pattern id="Iterator">
			<description>Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.</description>
			<interface id="Iterator">
				<method id="getNext">
					<type>Object</type>
				</method>
				<method id="hasNext">
					<type>boolean</type>
				</method>
			</interface>
			<class id="ConcreteIterator" implements="Iterator">
				<field id="collection"><type>ConcreteCollection</type></field>
				<field id="iterationState"><type>Object</type></field>
				<method id="ConcreteIterator">
					<type></type>
					<parameter id="c"><type>ConcreteCollection</type></parameter>
					<code>
						this.collection = c;
					</code>
				</method>
				<method id="hasNext">
					<type>boolean</type>
					<code>return false;</code>
				</method>
			</class>
			<interface id="Collection">
				<method id="createIterator">
					<type>Iterator</type>
				</method>
			</interface>
			<class id="ConcreteCollection" implements="Collection"></class>
		</pattern>
		<pattern id="Mediator">
			<description>Define an object that encapsulates how a set of objects interact.
			 Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and it lets you vary their interaction independently.</description>
			<interface id="Mediator">
				<method id="mediate">
					<type>void</type>
					<parameter id="colleague"><type>Colleague</type></parameter>
				</method>
			</interface>
			<class id="ConcreteMediator" implements="Mediator">
				<field id="concreteColleague1"><type>ConcreteColleague1</type></field>
				<field id="concreteColleague2"><type>ConcreteColleague2</type></field>
			</class>
			<class id="Colleague" isAbstract="false">
				<field id="mediator"><type>Mediator</type></field>
				<method id="operation">
					<type>void</type>
					<code>
						mediator.mediate(this);
					</code>
				</method>
			</class>
			<class id="ConcreteColleague1" extends="Colleague"></class>
			<class id="ConcreteColleague2" extends="Colleague"></class>
		</pattern>
		<pattern id="Memento">
			<description>Without violating encapsulation, capture and externalize an object's internal state so that the object can be restored to this state later.</description>
			<class id="Originator">
				<field id="state">
					<type>Object</type>
				</field>
				<method id="setMemento">
					<type>void</type>
					<parameter id="m">
						<type>Memento</type>
					</parameter>
					<code>state = m.getState();</code>
				</method>
				<method id="createMemento">
					<type>Memento</type>
					<code>return new Memento(state);</code>
				</method>
			</class>
			<class id="Memento">
				<field id="state"><type>Object</type></field>
				<method id="Memento">
					<type></type>
					<parameter id="state">
						<type>Object</type>
					</parameter>
					<code>this.state = state;</code>
				</method>
				<method id="getState">
					<type>Object</type>
					<code>return state;</code>
				</method>
				<method id="setState">
					<type>void</type>
					<parameter id="state">
						<type>Object</type>
					</parameter>
					<code>this.state = state;</code>
				</method>
			</class>
			<class id="Caretaker">
				<field id="memento"><type>Memento</type></field>
			</class>
		</pattern>
		<pattern id="Observer">
			<description> Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.</description>
			<class id="Subject">
				<field id="observers"><type>Observer[]</type></field>
				<method id="attach">
					<type>void</type>
					<parameter id="o"><type>Observer</type></parameter>
					<code>// observers.add(o);</code>
				</method>
				<method id="detach">
					<type>void</type>
					<parameter id="o"><type>Observer</type></parameter>
					<code>// observers.remove(o);</code>
				</method>
				<method id="notifyObservers">
					<type>void</type>
					<code>
						for (Observer o: observers) {
							o.update();
						}
					</code>
				</method>
			</class>
			<class id="ConcreteSubject" extends="Subject">
				<field id="subjectState"><type>Object</type></field>
				<method id="getState">
					<type>Object</type>
					<code>
						return subjectState;
					</code>
				</method>
				<method id="setState">
					<type>void</type>
					<parameter id="subjectState"><type>Object</type></parameter>
					<code>
						this.subjectState = subjectState;
					</code>
				</method>
			</class>
			<interface id="Observer">
				<method id="update">
					<type>void</type>
				</method>
			</interface>
			<class id="ConcreteObserver" implements="Observer">
				<field id="observerState"><type>Object</type></field>
				<field id="subject"><type>ConcreteSubject</type></field>
				<method id="update">
					<type>void</type>
					<code>observerState = subject.getState();</code>
				</method>
			</class>
		</pattern>
		<pattern id="State">
			<description>Allow an object to alter its behavior when its internal state changes. The object will appear to change its class.</description>
			<class id="Context">
				<field id="state"><type>State</type></field>
				<method id="request">
					<type>void</type>
					<code>
						state.handle();
					</code>
				</method>
			</class>
			<interface id="State">
				<method id="handle"><type>void</type></method>
			</interface>
			<class id="ConcreteStateA" implements="State"></class>
			<class id="ConcreteStateB" implements="State"></class>
		</pattern>
		<pattern id="Strategy">
			<description> Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.</description>
			<interface id="Strategy">
				<method id="algorithmInterface">
					<type>void</type>
				</method>
			</interface>
			<class id="ConcreteStrategyA" implements="Strategy"></class>
			<class id="ConcreteStrategyB" implements="Strategy"></class>
			<class id="ConcreteStrategyC" implements="Strategy"></class>
			<class id="Context">
				<field id="strategy">
					<type>Strategy</type>
				</field>
				<method id="contextInterface">
					<type>void</type>
					</method>
			</class>
		</pattern>
		<pattern id="Template Method">
			<description>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure.</description>
			<class id="AbstractClass" isAbstract="true">
				<method id="templateMethod">
					<type>void</type>
					<code>
						primitiveOperation1();
						primitiveOperation2();
						primitiveOperation3();
					</code>
				</method>
				<method id="primitiveOperation1" visibility="private">
					<type>void</type>
				</method>
				<method id="primitiveOperation2" visibility="protected" isAbstract="true">
					<type>void</type>
				</method>
				<method id="primitiveOperation3" visibility="protected" isAbstract="true">
					<type>void</type>
				</method>
			</class>
			<class id="ConcreteClassA" extends="AbstractClass"></class>
			<class id="ConcreteClassB" extends="AbstractClass"></class>
		</pattern>
		<pattern id="Visitor">
			<description>Represent an operation to be performed on the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates.</description>
			<interface id="Visitor">
				<method id="visitConcreteElementA">
					<type>void</type>
					<parameter id="concreteElementA"><type>ConcreteElementA</type></parameter>
				</method>
				<method id="visitConcreteElementB">
					<type>void</type>
					<parameter id="concreteElementB"><type>ConcreteElementB</type></parameter>
				</method>
			</interface>
			<interface id="Element">
				<method id="accept">
					<type>void</type>
					<parameter id="visitor"><type>Visitor</type></parameter>
				</method>
			</interface>
			<class id="ConcreteVisitor1" implements="Visitor"></class>
			<class id="ConcreteVisitor2" implements="Visitor"></class>
			<class id="ConcreteElementA" implements="Element">
				<method id="accept">
					<type>void</type>
					<parameter id="visitor"><type>Visitor</type></parameter>
					<code>visitor.visitConcreteElementA(this);</code>
				</method>
				<method id="operationA">
					<type>void</type>
				</method>
			</class>
			<class id="ConcreteElementB" implements="Element">
				<method id="accept">
					<type>void</type>
					<parameter id="visitor"><type>Visitor</type></parameter>
					<code>visitor.visitConcreteElementB(this);</code>
				</method>
				<method id="operationB">
					<type>void</type>
				</method>
			</class>
			<class id="ObjectStructure">
				<field id="element"><type>Element</type></field>
			</class>
			<class id="Client">
				<field id="objectStructure"><type>ObjectStructure</type></field>
				<field id="visitor"><type>Visitor</type></field>
			</class>
		</pattern>
	</category>
</GoF>